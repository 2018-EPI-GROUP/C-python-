# 学习总结

本周学习内容：

1. 复习单链表的头插法和尾插法

链表的结构体定义

    typedef struct node
    {
        DataType data;
        struct node * next;
    }LNode,*LinkList;

头插法

    LinkList Creat_LinkList1()
    {
        LinkList H=(LinkList)malloc(sizeof(LNode));
        H -> next = NULL;
        LNode * s;
        int x;
        scanf("%d",&x);
        while(x!=-1)
        {
            s = (LinkList)malloc(sizeof(LNode));
            s->data = x;
            s->next=H->next;
            H->next=s;
            scanf("%d",&x);
        }
        return H;
    }

尾插法

    LinkList H=(LinkList)malloc(sizeof(LNode))
    {
    H->next=NULL;
    LNode *s,*r=H;
    int x;
    scanf("%d",&x);
    while(x!=-1)
    {
        s = (LinkList)malloc(sizeof(LNode));
        s->data=x;
        r->next=s;
        r=s;
        scanf("%d",&x);
    }
    r->next=NULL;
    return H;
    }

2. 快速排序，

```
#include<stdio.h>

void kp(int* a, int size) {
	int i, j, k, t;
	if (size == 1 || size == 0) {
		return;
	}
	if (size == 2) {
		if (*a > *(a + 1)) {
			t= *(a + 1);
			*(a + 1) = *a;
			*a = t;
		}
		return;
	}
	k = *a;
	i = 0;
	j = size-1;
	while (i != j) {
		while (*(a + j) >= k && j>i) {
			j--;
		}
		while (*(a + i) < k && j>i) {
			i++;
		}
		if (j != i) {
			t = *(a + j);
			*(a + j) = *(a + i);
			*(a + i) = t;
		}
	}
	t= *(a + i);
	*(a + i) = *a;
	*a = t;
	kp(a, i+1);
	kp(a + i + 1, size - i - 1);
}
int main()
{
	int i, n;
	int a[1000];
	scanf_s("%d", &n);
	for (i = 0; i < n; i++) {
		scanf_s("%d", &a[i]);
	}
	kp(a, n);
	for (i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}
	getchar();
	getchar();
	return 0;
}

```