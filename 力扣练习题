一.俩个数之和

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) 
{   vector<int> result; 
        
	for(int i = 0; i < nums[max]; i++)
   { 
      for(int j = i + 1; j < nums[max]; j++) 
      {   
	     if(nums[i] + nums[j] == target) 
         {result[0] = i;         
          result[1] = j;                  
          return result;              
		 }        
	   }    
    }     
return result;
    }
};


二.回文数

 bool isPalindrome(int x) 
{ String tempX=String.valueOf(x);
    int i,j;	
	if (x < 0 || (x % 10 == 0 && x != 0))	
		return false;	
	if (x == 0)	
		return true;		
    if (x > 0)
    {   for(i=0,j=tempX.length()-1);i<j;i++,j--)
            if(i != j)  return false;
            if( i>= j)  return true;
	}
     }
   };
};

三.删除排序链表中的重复元素
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *s,*p,*q,*r,*t;
        int x;
        scanf("%d",&x);
        head=(ListNode*)malloc(sizeof(ListNode));
         head->next=NULL;
        while(x)
        { 
         s=(ListNode*)malloc(sizeof(ListNode));
          s->val=x;
         if(head==NULL) head=s;
         else r->next=s;
          r=s;
          scanf("%d",&x);
        }
        p=head->next;
        while(p->next)
        {
            q=p;
            while(q->next)
            { if(q->next->val==p->val)
                {
                    t=q->next;
                    q->next=t->next;
                    free(t);
                }
                else q=q->next;
            }p=p->next;
        }   
        return head;
};
};
