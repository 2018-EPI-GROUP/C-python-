
# logistics 回归

$A=\sigma(w^TX+b)$

其中$X$是一个$(n,m)$的矩阵，里面每一列为一个样本，一个样本共有 $n$个特征

$\sigma(z) = \frac{1}{1+e^-z}$

$l(a,y) = -(y\log(a)+(1-y)\log(1-a))$

$j(w,b) = \frac{1}{m}\sum_{i=1}^n{l(a,y)}$ 

$j$一般是一个凸函数，这样他存在一个极值点

$w := w - \alpha dw$， $dw$ 代表的是 $j$ 关于 $w$的倒数

$b := b - \alpha db$ 

$dz = A-Y$

$dw = \frac{1}{m} Xdz^T$

$db = \frac{1}{m} \sum dz$

```
import numpy as np 
import matplotlib.pyplot as plt
import h5py
from lr_utils import load_dataset
import time 

train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes = load_dataset()
'''
这个是用来传入猫的图片数据的,下面是这些信息的一些用途
train_set_x_orig ：保存的是训练集里面的图像数据（本训练集有209张64x64的图像）。
train_set_y_orig ：保存的是训练集的图像对应的分类值（【0 | 1】，0表示不是猫，1表示是猫）。
test_set_x_orig ：保存的是测试集里面的图像数据（本训练集有50张64x64的图像）。
test_set_y_orig ： 保存的是测试集的图像对应的分类值（【0 | 1】，0表示不是猫，1表示是猫）。
classes ： 保存的是以bytes类型保存的两个字符串数据，数据为：[b’non-cat’ b’cat’]。
'''
train_set_x_flatten  = train_set_x_orig.reshape(train_set_x_orig.shape[0],-1).T
test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[0], -1).T
''' reshape()方法可以重新组织数据，原数组（209,64,64,3)被重组为了 （209,12288）的数组，这样保证了每一行都是一个图片的数据，不会出现交叉,转置后为(12288,209)'''


'''
记学习样本为m个，学习特征为n个，则在本次中，(n,m) = (12288,209)
A = sigmoid(z)              sigmoid 是激活函数   A.shape = z.shape = (1,m)
z = w.T*x+b                 (1,n)*(n,m) = (1,m)  z.shape = (1,m)
l(A,Y)这个是损失函数            A.shape = (1.m)   Y.shape = (1,m)   l = -yloga+(1-y)log(1-a)
j(w,b) 成本函数                 w.shape = (n.1)  b.shape() = (1)


'''
def sigmoid(z):   #z是一个矩阵，(1,m) 激活函数
    return 1/(1+np.exp(-z))

def l(A,Y):     #这个函数返回是损失函数运算过后再求和后的结果
    return -(np.dot(Y,np.log(A.T))+np.dot(1-Y,np.log(1-A.T)))

n,m = 12288,209   #学习样本的初始和特征的初始
X = np.array(train_set_x_flatten/255)  #初始化X，同时把X的每个特征都在1-0之间
Y = np.array(train_set_y_orig)

X_c = np.array(test_set_x_flatten/255)
Y_c = np.array(test_set_y_orig)
#初始化
w = np.zeros((n,1))
b = 0     
dw = np.zeros((n,1))    #j关于w的倒数
#起点
b += 0.001
w += 0.001
alpha = 0.001

time1 = time.time()
for i in range(5000):
    z = np.dot(w.T,X) + b    #此处是计算z的值
    A = sigmoid(z)             #y帽的值，用A表示 A.shape = (1.m)
    j = (1/m)*l(A,Y)              #j的值
    dz = A - Y                  # j关于z的倒数                   
    dw = (1/m)*np.dot(X,dz.T)           # j关于w的倒数的平均值
    db = (1/m)*np.sum(dz)             # j关于b的倒数的平均值
    w -= alpha*dw
    b -= alpha*db
    
    if (i+1)%100 == 0:
        print("第"+str(i+1)+"次循环的成本函数值为："+str(j[0,0]))
        
        
time2 = time.time()

z_c = np.dot(w.T,X_c) + b
A_c = sigmoid(z_c)
sum_c = 0
for i in range(50):
    if abs(A_c[0,i] - Y_c[0,i])<=0.5:
        sum_c+=1
print("正确识别为："+str(sum_c)+"   百分比为："+str(sum_c*2)+"%")
print("时间："+str(time2-time1))

```
