## 力扣62.圆圈中最后剩下的数字

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

### 数学+递归法

python代码

```python
# Python 默认的递归深度不够，需要手动设置
sys.setrecursionlimit(100000)

def f(n,m):
    if n == 0:
        return 0
    x = f(n-1,m)
    return (m+x)%n
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        return f(n,m)
    
```

执行用时 :292 ms, 在所有 Python3 提交中击败了39.06%的用户

内存消耗 :91.6 MB, 在所有 Python3 提交中击败了100.00%的用户

c代码

```c
int lastRemaining(int n, int m){
	if (n == 0)
        return 0;
    int x;
    x = lastRemaining(n-1,m);
    return (m+x)%n;
}
```

执行用时 :16 ms, 在所有 C 提交中击败了7.29%的用户

内存消耗 :8.1 MB, 在所有 C 提交中击败了100.00%的用户

### 数学+迭代法

python代码

```python
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        f = 0
        for i in range(2,n+1):
            f = (m+f)%i
        return f
```

执行用时 :104 ms, 在所有 Python3 提交中击败了58.53%的用户

内存消耗 :13.6 MB, 在所有 Python3 提交中击败了100.00%的用户

c代码

```c
int lastRemaining(int n, int m){
int sum = 0;
for(int i=2;i<=n;i++){
	sum = (sum + m) % i;
}
return sum;
}
```

执行用时 :8 ms, 在所有 C 提交中击败了90.63%的用户

内存消耗 :5.2 MB, 在所有 C 提交中击败了100.00%的用户
